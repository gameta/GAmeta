<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<style>


/* Style the tab */
.tab {
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}

/* Style the buttons inside the tab */
.tab button {
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;

}

/* Change background color of buttons on hover */
.tab button:hover {
    background-color: #ddd;
}

/* Create an active/current tablink class */
.tab button.active {
    background-color: #ccc;
}

/* Style the tab content */
.tabcontent {
    display: none;
    //padding: 6px 12px;
    border: 1px solid #ccc;
    border-top: none;
}
/* Style the tab */
.vtab {
    float: left;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
    width: 30%;
    //min-height: 300px;
    //position: relative;
}

/* Style the buttons inside the tab */
.vtab button {
    display: block;
    background-color: inherit;
    color: black;
    padding: 22px 16px;
    width: 100%;
    border: none;
    outline: none;
    text-align: left;
    cursor: pointer;
    transition: 0.3s;

}

/* Change background color of buttons on hover */
.vtab button:hover {
    background-color: #ddd;
}

/* Create an active/current "tab button" class */
.vtab button.active {
    background-color: #ccc;
}

/* Style the tab content */
.vtabcontent {
    //float: left;
    //padding: 0px 12px;
    border: 1px solid #ccc;
    width: 100%;
    //border-left: none;
    //min-height: 300px;
    //position: relative;
    //top: 0;
	align-content: right;
}
</style>
</head>
<body>


<div id="wrapper" class="box" style="width:1000px; margin:0 auto;">
<div class="tab">
  <button class="tablinks" onclick="openCity(event, 'Research Tolerance')" >Research Tolerance</button>
  <button class="tablinks" onclick="openCity(event, 'Research Coding')" >Research Coding</button>
  <button class="tablinks" onclick="openCity(event, 'Design Projects')">Design Projects</button>
  <button class="tablinks" onclick="openCity(event, 'Coding Projects')" id="defaultOpen">Coding Projects</button>
</div>

<div id="Research Tolerance" class="tabcontent">
		<h3>Black and Dekker Swing Arm Saw</h3>
		<hr>
		<h3>Angular Features</h3>
		<hr>
		<h3>Cluster of Features</h3>
		<hr>
		<h3>Multi-constraint block</h3>
</div>

<div id="Research Coding" class="tabcontent">
<h3>OpenGL T-Maps Creation</h3>
<hr>
<h3>		T-Maps convolution</h3>
<hr>
<h3>		T-Maps intersection computation</h3>
</div>

<div id="Design Projects" class="tabcontent">

	<h3>	Leonardo Vinci Mechanism</h3>
	<hr>
		<h3>Futuristic Car Surface Design</h3>
		<hr>
		<h3>Tolerance Analysis Comparison</h3>
		<hr>
		<h3>Chip Substrate Plate Design Report</h3>
		<hr>
		<h3>TRIZ for Conceptual Design</h3>

</div>

<div id="Coding Projects" class="tabcontent">
  <div class="vtab">
    <button class="vtablinks" onclick="vopenCity(event, 'CAD 2002-2003')" >CAD 2002-2003</button>
    <button class="vtablinks" onclick="vopenCity(event, 'Computational Geometry 2003')" id="v4defaultOpen">Computational Geometry 2003</button>
    <button class="vtablinks" onclick="vopenCity(event, 'Computer Graphics 2005')">Computer Graphics 2005</button>
    <button class="vtablinks" onclick="vopenCity(event, 'Finite Element Analysis 2004')">Finite Element Analysis 2004</button>
    <button class="vtablinks" onclick="vopenCity(event, 'Others')">Others</button>

  </div>

  <div id="CAD 2002-2003" class="vtabcontent">
    <table style="border-left: 1px solid #ccc;"  cellpadding="20"><tr><td>
	    <h3>ACIS Based CSG CAD with Volume Surface and Center Extraction</h3>
	    <img src="untitled19.jpg" width="300">
		<img src="untitled20.jpg" width="300">
		<hr>
		<h3>ACIS Edge and Surface Picking for Feature Parameter Extraction</h3>
    </td></tr></table>
  </div>

  <div id="Computational Geometry 2003" class="vtabcontent">
  <table style="border-left: 1px solid #ccc;"  cellpadding="20"><tr><td>

  <a href="#SibsonsInterpolant">Sibson's Interpolant</a> &nbsp; &nbsp;
  <a href="#BezierSimplex">Bezier Simplex</a> &nbsp; &nbsp;
  <a href="#Hodograph">Hodograph</a> &nbsp; &nbsp;
  <a href="#Blossoms">Blossoms</a> &nbsp; &nbsp;<br>
  <a href="#CoonsPatches">Coons Patches</a> &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;
  <a href="#BezierSurface">Bezier Surface</a> &nbsp; &nbsp;
  <a href="#BezierCurves">Bezier Curves</a> &nbsp;
  <a href="#Delaunay">Delaunay</a> &nbsp; &nbsp;
<hr>
  <p>All these projects were completed as part of two courses taught by Prof. Gerald Farin at ASU. All programming was done in MFC, C++ and OpenGL.</p>

<hr>
    <h3 id="SibsonsInterpolant"> Sibson's Interpolant</h3>
			<p>CAGD Projects: Sibson's Interpolant:
			Sibson's Interpolant is mainly used in multivariate data interpolation. Here we have used it to model a terrain, where x,y,z data of some location is available. The idea is to basically triangulate the input points in the x,y plane. </p>
			<p>Then generate the voronoi diagram. The next step is to simulate an insertion of point. Due to the insertion of this point P, the neighboring area of the voronoi polygons is effected.</p>
			<img src="Sibson's1.jpg" width="300">
					<img src="Sibson's2.jpg" width="300">

			<p>Therefore, barycentric combination of these affected area and their z coordinates are used to generate the z value for the new insertion point. i.e. Pz = Sum(Zi*AREAi(reduced)/Parea, i = 0...n). Note that the point is not actually inserted but only simulated. Therefore, the original voronoi polygons remain unchanged. </p>

			<p>Similarly, points are simulated for the whole domain. Few examples with the interpolated terrain and triangulation are shown. The above scheme describes the linear interpolant. A C1 interpolant is supposed to be better. Please refer http://dilbert.engr.ucdavis.edu/~suku/nem/ for further applications.</p>
			<img src="Sibson's3.jpg" width="300">
			<img src="Sibson's4.jpg" width="300">
			<hr>
  	<h3 id="BezierSimplex"> Bezier Simplex</h3>
  			<p>CAGD Projects: Bezier Hyper-Tetrahedrons (4D): The concept of Bezier Tetrahedrons is an extension of bezier triangles. It basically uses barycentric coordinates to compute points. Here we are using 4D input to interpolate a Bezier 4D tetrahedron (simplex). Linear and Least square approximation will be used. Three of the parameters are x,y, z coordinates. The fourth parameter is the temperature distribution in the space. The input is shown in the first figure. The size of the sphere represents the magnitude of the temperature at that location. The input space is kept tetrahedral to make matter complicate. The linear and least squares out is shown in the following figures. Surprisingly, the least squares generates negative temperatures (spheres of different color) for some of the points.<p>
  			<img src="Tetrahedron.jpg" width="300">
			<img src="Tetrahedron2.jpg" width="300">
			<img src="Tetrahedron1.jpg" width="600">
			<hr>
	<h3 id="Hodograph"> Hodograph</h3>
			<p>CAGD Projects: Hodograph: Hodographs are polar velocity diagrams represented by a series of basis vectors. These can be used to develop bezier curve, if each basis vector is part of control polygon when attached end to end. The degree of the bezier curve is represented by the number of input basis vectors.</p>
			<p>Hodographs are used in tool path generation and plotting wind velocity. While plotting wind velocities, the velocity vectors become the basis vector for a hodograph.</p>
			<img src="Hodograph1.jpg" width="300">
			<img src="Hodograph2.jpg" width="300">
			<p>Since hodographs are represented by velocity vector, the velocity vector might change in direction or magnitude or both. The first figure shown when only the direction is changed, while the second and third include change in direction and magnitude.</p>
			<p>The Premise to this project was from a paper that says "if a vector is transformed succesively using transforms such as scale, rotate, translate (but not reflect), then the resultant bezier curve will be atleast C2 continuous".</p>
			<img src="Hodograph3.jpg" width="600">
			<hr>
	<h3 id="Blossoms"> Blossoms</h3>
			<p>CAGD Projects: Blossoms: Given any control polygon, a new function is defined with number of parameters same as the degree of the curve. The points on the bezier curve can be evaluated when all the parameters are same and within the range 0-1. The range of all curves represented by this new function are called blossoms of the bezier curve. For a quadratic curve (degree two), the a blossom surface (two parameter) can be formed representing all the blossoms. For a cubic curve (degree three), a blossom volume can be formed representing all the blossom for the bezier curve.</p>
			<img src="Blossom2.jpg" width="600">

			<p>Blossoms are used in fast subdivision of a bezier curve while using DeCasteljau algorithm. Blossoms have also been used in Graph Matching algorithms as blossoms are subset of the original Graph(Bezier Curve in CAGD).</p>
			<img src="Blossom3.jpg" width="300">
			<img src="Blossom1.jpg" width="300">
			<hr>
	<h3 id="CoonsPatches">Coons Patches and Reflection Lines</h3>
			  <p>CAGD Projects: Coons Patches and Reflection Lines: A coons patch tries to approximate the shape of the surface based on just the boundry curves (u=0, u=1, v=0 and v=1). The basic idea is to generate the points of the control polygon from the boundry control polygon. This requires a measure of goodness of the shape of the surface. While the standard Coon's algorithm is efficient various other algorithms are also proposed in the literature based on the permanence and modified permanence. An implementation of these algorithms was accomplished. Few examples are shown. The second part of the project involved generating reflection lines. The boundry curves for a mercedes fender was provided with the location of the lights and view direction. The resultant reflection lines on the surface were rendered in a post script file.</p>
			  <img src="untitled13.jpg" width="300">
			  <img src="untitled14.jpg" width="300"><br>
			  <img src="untitled15.jpg" width="300">
			  <img src="reflection lines.jpg" width="300">
			  <hr>
	<h3 id="BezierSurfaces">Bezier Surfaces</h3>
			  <p>CAGD Projects: Bezier Surfaces: Input is the control polygon for the surface. The points can be read from a file or provided in the textbox on the status bar. The surface is computed using the Decasteljau algorithm. An example of a saddle surface is shown. The control polygon when looking along the z-axis looks square.</p>
			  <img src="untitled8.jpg" width="300">
			  <img src="untitled10.jpg" width="300">
			  <p>Surface can be viewed with u-isoline, v-isoline or both. The surface can be edited by changing the control points. The control point can be translated along any vector. The surface will then be recomputed based on the new set of control polygon. Modified saddle is also shown in the next figure. Another example of mobius strip is shown.</p>
				<img src="untitled11.jpg" width="300">
			  <img src="untitled12.jpg" width="300">
			<hr>
    <h3 id="BezierCurves">Bezier Curves</h3>
			  <p>CAGD Projects: Bezier Curves: To create a bezier curve, input in the form of control polygon is required. Mouse clicks on the screen adds the consecutive control points. The a degree of the curve is specified. Although degree and number of control points are linked but we might want two bezier curve from 9 CP of degree 4 (each with 5 CP and one common point for C0 continuity). Bezier curves are constructed using the DeCasteljau algorithm. Its easier to debug and visualize if the results at each step are correct. The resultant curve is also shown.</p>
				<img src="untitled1.jpg" width="600">
			  <p>The next figure shows multiple curves. Curve editing, by moving control point (see next figure), or by deleting a whole curve is also implemented. Curves can be translated or rotated. The purpose of the editing tool is create a meaningful shape by combining several curves. A conceptual shape of the car is created as the final task for the project.</p>
				<img src="untitled3.jpg" width="300"><img src="untitled4.jpg" width="300">
			  <p>Once a desirable shape is created, it can be store as a PostScript file. (Viewable with GSviewer). The control points can also be saved as separate text file so as to open and edit later using the same program.</p>
			  	<img src="untitled6.jpg" width="600">
			  	<hr>
	<h3 id="Delaunay">Delaunay Triangulation and Voronoi</h3>
			  <p>Delaunay Triangulation of a simple point data. Point data can be added as x, y values or by click on the screen. A list of x, y values can be read from a text file also. The triangulation is built by adding each point one at a time. A virtual triangle of large proportions is added first so that any point added lies atleast within the virtual triangle. The virtual triangle or any edges connecting to the vertices of the virtual triangle are not displayed.
			  </p>
			  <img src="Delaunay.jpg" width="600">

			  <p>Convex hull of the point data.
			  Each triangle's edge is queried for its neighbor having a vertex as the vertex of the virtual triangle. The edge across which such neighbor exists is the edge belonging to the convex hull.
			  </p>
			  <img src="Convex Hull.jpg" width="600">



			  <p>A helpful tool to identify the neighbor of each triangle. This is helpful when debugging the code.</p>
			   <img src="Query Triangle.jpg" width="600">

			  <p>Voronoi diagram of the triangulation. Voronoi diagrams are the dual to the delaunay triangulation. Voronoi diagram can be obtained by connecting the circumcenter (center of the circumcircle) of each triangle to its neighbor's circumcenter. Voronoi diagrams have various uses in path planning but is also used in identifying the location of a mobile phone. Each polygon in the voronoi diagram represents the range served by each mobile tower. The location of the tower is the small circle (see fig.) in the voronoi polygon (vertex of delaunay triangulation).</p>
			  <img src="Voronoi.jpg" width="600">

			  <p>The adjacent figure shows an application of triangulation to create a triangular mesh, to be used in Finite Element Analysis. The respective Voronoi diagram is also displayed.</p>
			  <img src="Voronoi and Delaunay(Mesh).jpg" width="600">
		  </p></td></tr></table>
  </div>

  <div id="Computer Graphics 2005" class="vtabcontent">
    <table style="border-left: 1px solid #ccc;"  cellpadding="20"><tr><td>
    <p>All the projects given below were programmed using C++, OpenGL and MFC during computer graphics course taught by Prof. Nelson. <a href="http://www.holmes3d.net/graphics/skeleton/">OpenGLSkeleton</a> from holmes3d.net was used to simplify OpenGL based UI.</p>
		<h3 id="SmoothAnimations"> Fly through Smooth Animations using Keyframe</h3>
				<p>In this project, visual animation of flythrough was developed by first capturing keyframes around an object using camera's postion and orientation. The six parameters are then used in interpolation using linear BSpline and C2 continuous BSpline under euler angles and quaternions.</p>
					<img src="Animate.jpg" width="600">
				<p>The keyframes are shown as vertices of a 3d edges as shown below. The computed BSpline and its control point can also be visualized. The animation can be done by moving the camera along the interpolated coordinates or moving another object.</p>
					<img src="AnimateKeyFrames.jpg" width="300">
					<img src="InterpolatedPathCurve.jpg" width="300">
					<hr>
		<h3 id="RayTracing"> Ray Tracing</h3>
					<p>CG Projects: Raytracing:
					In this project, ray tracing algorithm based on location of camera, light and object is used to cast shadows and compute reflections. Multi-light based shadows can also be computed as shown below.</p>
					<img src="Shadow.jpg" width="300">
					<img src="MultiShadow.jpg" width="300">
					<p>Simple objects such as planes, spheres, ellipsoid and paraboloid were used. Combining texture mapping a reflections gives some unique results as shown below.</p>
					<img src="ReflectionsShadow.jpg" width="300">
					<img src="TextureReflectionsShadow.jpg" width="300">
					<hr>
		<h3 id="TextureMapping"> Texture Mapping</h3>
					<p>CG Projects: Texture Mapping:
					In this project, there were two inputs, an off file and a image texture file. The object in the off file was processed for display and either a boundary was identified or spherical/cylindrical mapping was used to map the texture using various algorithms onto the 3D object.</p>
					<img src="TextureMap14.gif" width="300">
					<img src="TextureMap15.gif" width="300">
					<p>Image below shows 3d surface model of staple gun and one with a fireworks image mapped onto it.</p>
					<img src="TextureMap12.gif" width="300">
					<img src="TextureMap13.gif" width="300">
<hr>
		<h3 id="BezierPatches"> Bezier Patches</h3>
							<p>CG Projects: Bezier Patches:
							In this project the input was 32 patch bezier control points. The output was to be generated using OpenGL based program to visualize the resultant surface. Flat and smooth shaded objects were displayed by computing face normals and vertex normals.</p>
							<img src="Project 1-1.jpg" width="600">
							<p>A shaded and wireframe utah tea pot is shown. An addition option was created so that each individual patch and patch boundary for other patches can be visualized with the patch normals. This output is also shown.</p>
							<img src="Project 1-2.jpg" width="300">
				<img src="Project 1-3.jpg" width="300">
    </td></tr></table>
</div>
<div id="Finite Element Analysis 2004" class="vtabcontent">
    <table style="border-left: 1px solid #ccc;"  cellpadding="20"><tr><td>
    <p>These two projects were completed in C++ and OpenGL as part of Graduate FEA programming course at ASU</p>
    	<h3>FEA Developer Projects: 3D Trusses</h3>
		<p>
			This project was an extension of the 2D project. Various trusses were taken as example cases. Two of the example are shown here. One for a cantilever type truss. Other one is simply supported beam on one end. Actual output was through a formatted text file.</p>
			<p>The program implemented can solve for Displacement loads, Forces, Temperature loads. The OpenGL output shows the original shape of the truss, the deformed shape and location of the constraints and the load.</p>
			<img src="Truss 1.jpg" width="300">
			<img src="Truss 2.jpg" width="300">

		<hr>
		<h3>FEA Developer Projects: 2D Q4 (4 Noded Quadrilateral) Elements</h3>
			<p>FEA Developer Projects: 2D Q4 (4 Noded Quadrilateral) Elements: In this project we were supposed to create a Finite Element Program for solving 2D Plane Stress, Plane Strain problems using 4 Noded Quadrilateral. This included incorporating the shape functions used with 4 Noded Quadrilateral. Utilizing skyline scheme for modelling the problem in a matrix form. Then creating a solution using Gaussian Elimination. </p>
			<img src="16els.jpg" width="300">
			<img src="8els.jpg" width="300">
			<p>The various classes developed were: CVector, GaussWeight, CMatrix, CNode, CElement, CMaterialGroup, CNodalResponse, CElemental Response and CFeat. CFeat is the main class containing all the structures. The flow of the program was: Read Problem Size, Echo Input, ConstructK, ConstructF, ImposeBC, Solve, ComputeResponse, Create Output. The results from analysis with two cantilever beams is shown graphically. Range of Gray color represents lower to higher stress. Temperature loads can also be incorporated.</p>


    </td></tr></table>
</div>
<div id="Others" class="vtabcontent">
    <table style="border-left: 1px solid #ccc;"  cellpadding="20"><tr><td>
	    <h3>Shortest Path Algorithm (Travelling Salesman)</h3>
	    <hr>
		<h3>Line Follower and Constant Velocity Single Cylinder IC Engine Car</h3>
		<hr>
		<h3>B+ trees</h3>
    </td></tr></table>
</div>
</div>


</div>
<script>
var htablist=["Research Tolerance","Research Coding","Design Projects","Coding Projects"];
var vtabdefault=["v1defaultOpen","v2defaultOpen","v3defaultOpen","v4defaultOpen"];
function openCity(evt, cityName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");

    }
    document.getElementById(cityName).style.display = "block";
    evt.currentTarget.className += " active";
    document.getElementById(vtabdefault[htablist.indexOf(cityName)]).click();
    //document.getElementById("v1defaultOpen").click();

}

function vopenCity(evt, cityName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("vtabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("vtablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(cityName).style.display = "block";
    evt.currentTarget.className += " active";

}
document.getElementById("defaultOpen").click();
//document.getElementById("v1defaultOpen").click();
//document.getElementById("v2defaultOpen").click();


$(".vtab").css("height",$( ".vtabcontent" ).height());

</script>

</body>
</html>
